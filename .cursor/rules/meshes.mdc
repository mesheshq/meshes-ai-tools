---
description: Rules for integrating with the Meshes event routing platform (meshes.io). Use when writing code that emits events, creates integrations, or connects to CRMs/webhooks/email tools via Meshes.
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: false
---

# Meshes Integration Rules

You are helping a developer integrate with **Meshes** (https://meshes.io), a universal event routing and integration platform for SaaS applications. Meshes handles fan-out, retries, and delivery of product events to tools like HubSpot, Intercom, Salesforce, Resend, Mailchimp, Zoom, and custom webhooks.

**API Reference:** https://docs.meshes.dev
**Documentation:** https://meshes.io/docs

## Core Concepts

Meshes has four core primitives:

- **Workspace**: A tenant-scoped container. Each workspace has its own connections, rules, event logs, and a publishable key. In multi-tenant apps, create one workspace per customer.
- **Connection**: A configured destination within a workspace (e.g., a HubSpot OAuth connection, a Salesforce API key, a webhook URL). Connections hold per-tenant credentials, metadata, and action configuration.
- **Rule**: Binds an event type to a connection. Rules specify which connection receives the event and include a `metadata` object with at minimum an `action` field that determines what the destination does (e.g., `create_or_update_contact`). Rules can be filtered by `event`, `resource`, and `resource_id`.
- **Event**: A JSON payload emitted by your application (e.g., `user.signup`, `payment.failed`, `lead.created`). Events are routed to matching rules within a workspace. Each event tracks delivery status across all matched rules with `rule_events`.

## API Base URL

```
https://api.meshes.io
```

All endpoints are prefixed with `/api/v1/`.

## Authentication

Meshes supports two authentication methods. Full details at: https://meshes.io/docs/api/authentication

### Bearer Token (Management API)

For server-side operations — managing workspaces, connections, rules, and reading events. Meshes uses short-lived HS256 JWTs (max 60 second expiry) minted from your machine key credentials (access key + secret key + org ID).

**Preferred: Use the `@mesheshq/api` SDK** which handles token generation automatically:

```typescript
import MeshesApiClient from "@mesheshq/api";

const client = new MeshesApiClient(
  process.env.MESHES_ORG_ID!,
  process.env.MESHES_ACCESS_KEY!,
  process.env.MESHES_SECRET_KEY!
);

const workspaces = await client.get("/workspaces");
```

If you need to generate tokens manually (e.g., for direct `fetch` calls), use the `jose` library:

```typescript
import { SignJWT } from "jose";

const accessKey = process.env.MESHES_ACCESS_KEY!;
const secretKey = process.env.MESHES_SECRET_KEY!;
const orgId = process.env.MESHES_ORG_ID!;

async function createMeshesToken() {
  const key = new TextEncoder().encode(secretKey);
  return new SignJWT({ org: orgId })
    .setProtectedHeader({ alg: "HS256", typ: "JWT", kid: accessKey })
    .setIssuer(`urn:meshes:m2m:${accessKey}`)
    .setAudience("meshes-api")
    .setIssuedAt()
    .setExpirationTime("30s")
    .sign(key);
}

// Use in requests:
const token = await createMeshesToken();
const headers = {
  "Authorization": `Bearer ${token}`,
  "Content-Type": "application/json",
};
```

**Important:** Tokens expire in ≤60 seconds. Generate a fresh token for each request or short batch of requests. Never hardcode or cache tokens long-term.

### Publishable Key (Event Ingestion)

For emitting events — safe to expose in frontend code and commit to repos. Sent via the `X-Meshes-Publishable-Key` header. Only grants access to event endpoints — no management API access.

**Use `https://events.meshes.io` for event ingestion** — this endpoint is CORS-friendly and designed for client-side use. The `https://api.meshes.io` base URL is for management APIs only and does not support CORS.

```typescript
const headers = {
  "X-Meshes-Publishable-Key": "pk_live_...",
  "Content-Type": "application/json",
};
```

Each workspace has its own publishable key, returned when you `GET /api/v1/workspaces/{workspace_id}`.

See: https://meshes.io/docs/events/send-events

## Official SDKs

Meshes provides two official Node.js SDKs:

- **`@mesheshq/api`** — Management API SDK (uses access key + secret key)
- **`@mesheshq/events`** — Events SDK (uses publishable key for emitting events)

See: https://meshes.io/docs/api/sdks

## Supported Integration Types

```
activecampaign | aweber | hubspot | intercom | mailchimp | mailerlite | resend | salesforce | webhook | zoom
```

## Emitting Events

This is the primary integration point. Your app emits events; Meshes handles routing and delivery.

### Single Event — `POST /api/v1/events`

Accepts either Bearer token or Publishable Key auth. Use `https://events.meshes.io` for client-side/CORS-friendly requests, or `https://api.meshes.io` for server-side.

```typescript
async function emitEvent(
  workspaceId: string,
  event: string,
  payload: Record<string, unknown>
) {
  const response = await fetch("https://events.meshes.io/api/v1/events", {
    method: "POST",
    headers: {
      "X-Meshes-Publishable-Key": process.env.MESHES_PUBLISHABLE_KEY!,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      workspace: workspaceId, // UUID
      event, // e.g., "user.signup"
      payload,
      // Optional:
      // resource: "user",
      // resource_id: "usr_abc123",
      // type: "event",       // defaults to "event"
    }),
  });

  if (!response.ok) {
    throw new Error(`Meshes event failed: ${response.status}`);
  }

  return response.json();
  // Returns: { event: { id, event, workspace, created_by, created_at, ... } }
}
```

### Bulk Events — `POST /api/v1/events/bulk`

Send up to 100 events in a single request. Returns 201 on full success, 207 on partial success.

```typescript
async function emitBulkEvents(
  events: Array<{
    workspace: string;
    event: string;
    payload: Record<string, unknown>;
    resource?: string;
    resource_id?: string;
  }>
) {
  const response = await fetch("https://events.meshes.io/api/v1/events/bulk", {
    method: "POST",
    headers: {
      "X-Meshes-Publishable-Key": process.env.MESHES_PUBLISHABLE_KEY!,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(events), // Array of 1-100 event objects
  });

  return response.json();
  // Returns: { count, error_count?, records: [...] }
}
```

### Event Payload Schema

The `payload` object has these recognized top-level fields (all optional, plus any custom fields via `additionalProperties`):

```typescript
interface EventPayload {
  email?: string; // format: email — required for CRM contact matching
  id?: string; // resource identifier for deduplication
  ip_address?: string;
  name?: string;
  first_name?: string;
  last_name?: string;
  phone?: string;
  resource_url?: string;
  [key: string]: unknown; // additional custom fields
}
```

**Always include `email`** when the event relates to a person — CRM and email connections rely on it for contact matching.

### Event Naming Convention

Use descriptive event names. Common patterns:

```
user.signup
user.updated
payment.failed
payment.succeeded
lead.created
trial.expiring
subscription.cancelled
form.submitted
```

## Workspaces

### List Workspaces — `GET /api/v1/workspaces`

```typescript
// Returns: { count, limit, next_cursor, records: [{ id, name, description, created_at, updated_at }] }
```

### Get Workspace — `GET /api/v1/workspaces/{workspace_id}`

Returns workspace details **including the publishable key**:

```typescript
// Returns: { id, name, description, created_at, updated_at, publishable_key: { public_key, name } }
```

### Create Workspace — `POST /api/v1/workspaces`

```typescript
await fetch("https://api.meshes.io/api/v1/workspaces", {
  method: "POST",
  headers,
  body: JSON.stringify({
    name: "Acme Corp", // 3-50 chars, alphanumeric + space/underscore/dash
    description: "Production workspace for Acme", // optional, max 1024 chars
  }),
});
// Returns: { workspace: { id, name, description, created_at, updated_at } }
```

### Update Workspace — `PUT /api/v1/workspaces/{workspace_id}`

```typescript
// Body: { name: string (required), description?: string | null }
```

### Workspace Sub-Resources

- `GET /api/v1/workspaces/{workspace_id}/connections` — list connections in workspace
- `GET /api/v1/workspaces/{workspace_id}/rules` — list rules in workspace
- `GET /api/v1/workspaces/{workspace_id}/events` — list events in workspace (supports `?limit`, `?cursor`, `?event`, `?resource`, `?resource_id`, `?status` filters)

## Connections

Connections are configured destinations within a workspace.

### List Connections — `GET /api/v1/connections`

Returns all connections across the organization.

### Get Connection — `GET /api/v1/connections/{connection_id}`

### Create Connection — `POST /api/v1/connections`

```typescript
await fetch("https://api.meshes.io/api/v1/connections", {
  method: "POST",
  headers,
  body: JSON.stringify({
    workspace: "uuid-here",
    type: "hubspot", // one of the supported integration types
    name: "HubSpot Prod", // 1-128 chars, alphanumeric + space/underscore/dash
    metadata: {
      /* connector-specific config */
    },
    hidden: false, // optional, default false
  }),
});
```

### Update Connection — `PUT /api/v1/connections/{connection_id}`

```typescript
// Body: { name: string (required), metadata: object (required), hidden?: boolean }
```

### Delete Connection — `DELETE /api/v1/connections/{connection_id}`

```typescript
// Optional body: { force_delete?: boolean }
// Returns 409 if connection has active rules (use force_delete to override)
```

### Connection Sub-Resources

- `GET /api/v1/connections/{connection_id}/actions` — get available actions for this connection type
- `GET /api/v1/connections/{connection_id}/fields` — get destination field catalog (supports `?refresh=true`)
- `GET /api/v1/connections/{connection_id}/mappings/default` — get default field mappings
- `PUT /api/v1/connections/{connection_id}/mappings/default` — update default field mappings

### Field Mapping Schema

Mappings use a versioned schema with source → destination field transforms:

```typescript
{
  schema_version: 1,
  fields: [
    {
      dest: "email",                           // destination field key
      source: { type: "path", value: "email" }, // from event payload
      transforms: [{ type: "lower" }, { type: "trim" }],
      on_error: "skip_field",                   // or "warn_action" | "fail_action"
    },
    {
      dest: "lifecycle_stage",
      source: { type: "literal", value: "lead" }, // static value
    },
  ],
}
```

**Source types:**

- `path` — references a field in the event payload (e.g., `"email"`, `"user.email"`)
- `literal` — a static value (string, number, boolean, or null)

**Available transforms:** `to_string`, `to_number`, `to_boolean`, `to_date`, `to_datetime`, `default`, `trim`, `lower`, `upper`, `substring`

## Rules

Rules bind event types to connections with action configuration.

### List Rules — `GET /api/v1/rules`

Supports query filters: `?event=user.signup&resource=user&resource_id=plan_pro`

### Get Rule — `GET /api/v1/rules/{rule_id}`

### Create Rule — `POST /api/v1/rules`

```typescript
await fetch("https://api.meshes.io/api/v1/rules", {
  method: "POST",
  headers,
  body: JSON.stringify({
    workspace: "workspace-uuid",
    connection: "connection-uuid",
    event: "user.signup",
    metadata: {
      action: "create_or_update_contact", // required — the action the destination performs
      // Additional action-specific fields:
      // id, name, value, key, data, option, option_value
    },
    // Optional:
    // resource: "user",
    // resource_id: "plan_pro",       // pattern: ^[A-Za-z0-9._:-]{1,64}$
    // active: true,                  // default true
    // hidden: false,                 // default false
  }),
});
```

### Delete Rule — `DELETE /api/v1/rules/{rule_id}`

## Events (Reading)

### List Events — `GET /api/v1/events`

Supports `?limit` (1-200, default 50) and `?cursor` for pagination.

### Get Event — `GET /api/v1/events/{event_id}`

Returns event with delivery status and `rule_events` array showing per-rule delivery:

```typescript
// Each rule_event includes:
// { id, connection, rule, integration_type, status, attempt_count, last_error, ... }
// status: "pending" | "processing" | "completed" | "failed"
```

### Get Event with Payload — `GET /api/v1/events/{event_id}/payload`

Same as above but includes the full event `payload` object.

### Retry Failed Rule — `POST /api/v1/events/{event_id}/rules/{rule_id}/retry`

Manually retry a failed rule delivery.

## Pagination

All list endpoints use cursor-based pagination:

```typescript
interface PaginatedResponse<T> {
  count: number;
  limit: number;
  next_cursor: string | null; // pass as ?cursor= for next page
  records: T[];
}
```

## Common Integration Patterns

### On User Signup

```typescript
await emitEvent(workspaceId, "user.signup", {
  email: user.email,
  first_name: user.firstName,
  last_name: user.lastName,
  id: user.id,
  plan: "pro",
  source: "organic",
});
```

### Multi-Tenant Pattern

```typescript
// Each customer gets their own workspace with their own publishable key
async function onTenantEvent(
  tenantWorkspaceId: string,
  event: string,
  payload: object
) {
  await emitEvent(tenantWorkspaceId, event, payload);
}
```

### Form Submission (Frontend with Publishable Key)

```typescript
// Safe for client-side — publishable key is safe to commit to repos
await fetch("https://events.meshes.io/api/v1/events", {
  method: "POST",
  headers: {
    "X-Meshes-Publishable-Key": "pk_live_...",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    workspace: "workspace-uuid",
    event: "form.submitted",
    payload: { email: formData.email, name: formData.name },
  }),
});
```

## Error Handling

Event emission should not block your core application flow:

```typescript
try {
  await emitEvent(workspaceId, "user.signup", payload);
} catch (error) {
  console.error("Failed to emit Meshes event:", error);
}
```

API errors return `{ message: string, error?: any }`.

**Common status codes:**

- `400` — Invalid request body
- `401` — Missing or invalid authentication
- `404` — Resource not found
- `409` — Conflict (duplicate name, active rules on connection, etc.)
- `422` — Unprocessable entity (invalid mapping schema)
- `429` — Rate limited

## What NOT to Do

- **Don't build retry logic for destinations** — Meshes handles retries and dead-letter queues.
- **Don't fan out events yourself** — emit once, let rules handle fan-out to multiple destinations.
- **Don't store destination credentials in your app** — connections in Meshes manage OAuth tokens and API keys.
- **Don't hardcode workspace UUIDs** — store them per tenant in your database.
- **Don't use Bearer tokens in frontend code** — use the publishable key (`X-Meshes-Publishable-Key`) for client-side event emission.
- **Don't commit access keys or secret keys to repos** — use environment variables. Publishable keys are safe to commit.
- **Don't use `api.meshes.io` from the browser** — use `events.meshes.io` for frontend event emission (CORS-friendly).

## Integrations: Connections & Rules Pattern

Meshes integrations are self-describing. The `GET /api/v1/integrations` endpoint returns metadata that tells you everything needed to create connections and rules for each integration type. **Always call this endpoint first** when setting up a new integration.

### Step 1: Discover integration metadata

```
GET /api/v1/integrations
```

Each integration defines:

- **`authentication`** — how to create a connection (what credentials are needed)
- **`actions`** — what rules can do (what the `metadata.action` field should be)

### Step 2: Create a connection

The `authentication` object tells you what goes in the connection's `metadata`:

- **`api_key`** type — the `fields` array lists required credentials. Put them in `metadata`.
- **`oauth`** type — no fields needed in metadata; OAuth flow is handled by the Meshes dashboard.
- **`none`** type — check `fields` for any config (e.g., webhook URL).

Example — ActiveCampaign (api_key auth):

```typescript
// Integration metadata says: authentication.type = "api_key"
// with fields: [{ key: "api_url", ... }, { key: "api_key", ... }]
await createConnection({
  workspace: workspaceId,
  type: "activecampaign",
  name: "My ActiveCampaign",
  metadata: {
    api_url: "https://myaccount.api-us1.com",
    api_key: "your-activecampaign-api-key",
  },
});
```

Example — HubSpot (oauth auth):

```typescript
// Integration metadata says: authentication.type = "oauth"
// OAuth connections are created via the Meshes dashboard UI.
// The connection will already exist — just reference its ID in rules.
```

Example — Webhook (no auth):

```typescript
// Integration metadata says: authentication.type = "none"
// with fields: [{ key: "url", ... }]
await createConnection({
  workspace: workspaceId,
  type: "webhook",
  name: "My Webhook",
  metadata: {
    url: "https://example.com/webhook",
  },
});
```

### Step 3: Discover available actions for a connection

Each integration has an `actions` object. Each action has:

- **`key`** — the value to use in `metadata.action` when creating a rule
- **`data`** — lists of selectable items (lists, tags, campaigns, etc.) needed for the rule
- **`fields`** — which metadata fields the rule requires (e.g., `["id"]` or `["id", "value"]`)

To get the actual selectable items for a specific connection, call:

```
GET /api/v1/connections/{connection_id}/actions
```

This returns the **live data** for each action — the actual lists, tags, campaigns, properties, etc. from the connected account.

### Step 4: Create rules with the right metadata

Rules require `metadata.action` plus additional fields from the action's `fields` array, populated with IDs from the action data.

**Simple actions** (most common) — require an `id` from the action data:

```typescript
// HubSpot add_to_list: action data has "lists" with [{id: "5", name: "Unit Test List"}, ...]
// Action fields: ["id"]
await createRule({
  workspace: workspaceId,
  connection: hubspotConnectionId,
  event: "user.signup",
  metadata: {
    action: "add_to_list",
    id: "5", // list ID from action data
  },
});

// Intercom add_tag: action data has "tags" with [{id: "123", name: "new-user"}, ...]
await createRule({
  workspace: workspaceId,
  connection: intercomConnectionId,
  event: "user.signup",
  metadata: {
    action: "add_tag",
    id: "123", // tag ID from action data
  },
});
```

**Advanced actions** — require additional fields like `value`:

```typescript
// HubSpot update_property: action data has "properties" with options
// Action fields: ["id", "value"]
// Property: {id: "lifecycle_stage", options: [{value: "lead"}, {value: "customer"}]}
await createRule({
  workspace: workspaceId,
  connection: hubspotConnectionId,
  event: "payment.succeeded",
  metadata: {
    action: "update_property",
    id: "lifecycle_stage", // property ID from action data
    value: "customer", // option value from property options
  },
});
```

**Actions with extra fields** (e.g., Resend send_email_template):

```typescript
// Resend send_email_template: action data has "templates"
// Action fields: ["id", "subject", "from"]
// Also has "field" kind data items for subject and from
await createRule({
  workspace: workspaceId,
  connection: resendConnectionId,
  event: "user.signup",
  metadata: {
    action: "send_email_template",
    id: "tmpl_abc123", // template ID from action data
    // Optional overrides (defined as "field" kind in data):
    // subject: 'Welcome!',
    // from: 'Team <team@example.com>',
  },
});
```

### Action pattern summary

| Integration    | Action                                     | metadata fields                     | Data source          |
| -------------- | ------------------------------------------ | ----------------------------------- | -------------------- |
| ActiveCampaign | `add_to_list` / `remove_from_list`         | `action`, `id`                      | lists                |
| ActiveCampaign | `add_tag` / `remove_tag`                   | `action`, `id`                      | tags                 |
| AWeber         | `add_to_list` / `remove_from_list`         | `action`, `id`                      | lists                |
| HubSpot        | `add_to_list` / `remove_from_list`         | `action`, `id`                      | lists                |
| HubSpot        | `update_property`                          | `action`, `id`, `value`             | properties + options |
| Intercom       | `add_tag` / `remove_tag`                   | `action`, `id`                      | tags                 |
| Mailchimp      | `add_to_list` / `remove_from_list`         | `action`, `id`                      | lists                |
| MailerLite     | `add_to_group` / `remove_from_group`       | `action`, `id`                      | groups               |
| Resend         | `add_to_segment` / `remove_from_segment`   | `action`, `id`                      | segments             |
| Resend         | `send_email_template`                      | `action`, `id`, `subject`?, `from`? | templates            |
| Salesforce     | `add_to_campaign` / `remove_from_campaign` | `action`, `id`                      | campaigns            |
| Salesforce     | `update_property`                          | `action`, `id`, `value`             | properties + options |
| Webhook        | `send_webhook`                             | `action`                            | (none)               |
| Zoom           | `add_meeting_registrant`                   | `action`, `id`                      | meetings             |
| Zoom           | `add_webinar_registrant`                   | `action`, `id`                      | webinars             |

### Workflow for AI agents

When asked to set up an integration:

1. `GET /api/v1/integrations` — discover auth requirements and available actions
2. Check if a connection already exists: `GET /api/v1/workspaces/{id}/connections`
3. If not, create the connection with the right `metadata` based on `authentication.fields`
4. `GET /api/v1/connections/{id}/actions` — get live action data (lists, tags, etc.)
5. Create rules with `metadata.action` + IDs from the action data
6. Test with `POST /api/v1/events` and verify with `GET /api/v1/events/{id}`
